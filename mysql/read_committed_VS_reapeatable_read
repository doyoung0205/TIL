두 격리수준의 차이는 tx 시작되었을때 변경된 데이터를 읽을거냐 tx 시작할때 데이터를 읽냐의 차이 (팬텀리드가 발생하느냐 안하느냐)

두 격리 수준 모두 동시성 이슈는 여전히 존재 
정합성이 필요한 로직에는 격리수준에 의존하지 않고 Lock 을 사용!

팬텀리드가 발생하면... 서비스에서 어떤 문제가 발생하나요?
사용자가 구매 직전에 확인했을때는 재고수량이 있는것으로 나와있으나 구매 시점에 재고수량을 보면 수량이 없는 상황정도

JPA 의 영속성 컨텍스트 1차 캐시 측면에서도 설정된 DB 격리수준과 별개로 `reapeatable_read` 같은 상황이 발생됨!
-> 하지만 findById 같은 부분에서만 해당되고 JPQL 이나 querydsl 에서는  `read_committed` 같은 상황이 발생됨

그럼에도 불구하고 reapeatable_read 를 사용하면 불필요하게 MVCC 를 사용하게 됨!

reapeatable_read : MVCC 를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여준다.
MVCC : InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드값을 변경한다.

언두 공간이 커지면 DB 엔진의 속도가 느려질 수 있으니 주의하자.
