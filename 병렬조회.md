예를들어 1000개 이상 조회 하는 경우 (조회 할 시 연관 테이블이 많은경우) fetch 양이 과도하게 발생해서 성능에 문제가 생길 수 있다.

따라서 병렬조회로 이 문제를 해결 할 수 있다.

자바에서는 CompletableFuture 를 통해서 구현할 수 있다.

```


    private List<ItemResult> getResultList(List<Long> itemIdList, final boolean preserveOrder) {
        if (isEmpty(itemIdList)) {
            return List.of();
        }
        try {
            final List<List<Long>> partitionedItemIdList = Lists.partition(itemIdList, PARTITION_SIZE);
            final List<CompletableFuture<List<ApiFetchResult>>> futureList =
                    partitionedItemIdList.stream()
                            .map(idList -> supplyAsyncCallApi(idList, preserveOrder))
                            .collect(toList());

            final List<ApiFetchResult> resultList = futureList.stream()
                    .map(CompletableFuture::join)
                    .flatMap(Collection::stream)
                    .collect(toList());


            if (preserveOrder) {
                Map<Long, ApiFetchResult> resultMapById = resultList.stream()
                        .collect(toMap(ApiFetchResult::getId, Function.identity()));
                return itemIdList.stream()
                        .filter(resultMapById::containsKey)
                        .map(resultMapById::get)
                        .collect(toList());
            }

            return resultList;
        } catch (RetryableException error) {
            log.warn("ItemApiReader > itemServiceApiCaller.getItemList Error / request={}, StackTrace={}", itemIdList, error);
            return Collections.emptyList();
        }
    }

    private CompletableFuture<List<ItemResult>> supplyAsyncCallApi(List<Long> idList, boolean preserveOrder) {
        return supplyAsync(() -> apiCaller.getList(idList, preserveOrder).getData())
                .exceptionally(error -> {
                    log.warn("supplyAsyncCallApi  Error / request={}, StackTrace={}", idList, error);
                    return Collections.emptyList();
                });
    }

```
